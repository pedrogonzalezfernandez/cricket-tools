Add OSC control to the existing web app so that everything the Conductor can control in the browser can also be controlled by OSC messages sent from the same computer running the app (e.g., from a Max/MSP patch). OSC must affect players exactly as if the conductor moved the controls in the browser.
Goal
* OSC → app → players in real time
* OSC must also update the conductor UI state (so the sliders/scene selector reflect the new values)
* The system must be stable and professional, meaning players must have a persistent numeric ID during a session that the conductor can see and that OSC can target reliably.

1) Stable player IDs (required)
Implement a server-assigned fixed numeric PlayerID:
* When a player connects and enters their name, the server assigns them a unique integer playerId (1, 2, 3…).
* This playerId must be stable during the session and must NOT depend on socket id.
* If a player disconnects and later reconnects, it’s OK if they get a new playerId (session-stable is enough), but do not renumber existing connected players.
* The conductor UI must display each player as: PlayerID – Name (example: 3 – Pedro)
* OSC addressing will use this playerId.

2) OSC input (required)
The app must listen for OSC messages coming from localhost (same machine):
* Transport: UDP OSC
* Bind address: 127.0.0.1
* Port: choose a clear default like 9000
* Add a note in the README: “Send OSC to 127.0.0.1:9000”
OSC message formats (required)
A) Control any conductor control (players + global)
Use ONE main OSC address:
Address: /conductor Arguments:
1. target (int)
2. control (int)
3. value (float/int)
Where:
* target identifies WHO is being controlled:
    * target = 0 means global conductor controls (e.g., scene selection)
    * target = playerId means controls for that specific player
* control identifies WHICH conductor control is being changed:
    * control = 1 → player pitch slider
    * control = 2 → player interval/density slider in milliseconds
    * control = 100 → scene selector (global)
* value is the new value for that control:
    * pitch: whatever numeric format the app already uses internally for pitch
    * interval: milliseconds
    * scene: numeric scene index (e.g., 1 = Audio Score scene)
Examples:
* /conductor 3 1 72 → set PlayerID 3 pitch to 72
* /conductor 3 2 800 → set PlayerID 3 interval to 800 ms
* /conductor 0 100 1 → set scene to 1
B) Optional “apply to all players” (nice to have)
Support:
* target = -1 meaning “apply to all connected players” Examples:
* /conductor -1 2 1200 → set interval 1200 ms for all players

3) Behavior requirements (required)
* OSC control must behave exactly like the conductor UI:
    * Changing a player’s pitch changes what they hear AND see.
    * Changing a player’s interval changes the speed/density.
    * Changing the scene changes the scene for everyone (according to existing rules).
* OSC must work even if no conductor browser tab is open (server still receives OSC and updates players).
* If conductor tabs are open, they must show the updated values immediately when OSC changes something.
* If an OSC message references a playerId that is not currently connected, ignore it safely (do not crash).

4) Safety / validation (required)
* Only accept OSC packets from localhost (127.0.0.1).
* Clamp values to valid ranges that match the existing controls (pitch range, interval range, scene range).
* Log a short server-side message whenever an OSC message is applied: OSC applied: target=..., control=..., value=...
